<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A Valentine's Quest</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- Google Fonts: Press Start 2P -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            background-color: #1a1a1a;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
        }

        /* Canvas Styling */
        canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* CRT Overlay */
        .scanlines {
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0),
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.05) 50%,
                    rgba(0, 0, 0, 0.05));
            background-size: 100% 4px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* UI Styling */
        .dialogue-box {
            border: 4px solid #fff;
            background-color: #2563eb;
            box-shadow: 0 4px 0px #1e3a8a;
            text-shadow: 2px 2px 0 #000;
        }

        .dialogue-box p {
            white-space: pre-wrap;
            line-height: 1.6;
        }

        .btn-retro {
            border: 2px solid #fff;
            box-shadow: 0 4px 0px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-retro:active {
            transform: translateY(4px);
            box-shadow: 0 0 0;
        }

        /* Choice Menu */
        .choice-menu {
            background-color: #ef4444;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body class="h-screen w-screen flex items-center justify-center bg-gray-900 text-white relative">
    <audio id="bgm" src="bgm.mp3" loop></audio>


    <div id="game-wrapper"
        class="relative w-full max-w-2xl aspect-video bg-black rounded-xl overflow-hidden border-4 border-gray-700 shadow-2xl">
        <canvas id="gameCanvas" class="w-full h-full block"></canvas>
        <div class="scanlines"></div>

        <!-- Dialogue Box -->
        <div id="dialogue-container" class="absolute bottom-6 left-6 right-6 hidden z-20">
            <div class="dialogue-box p-4 rounded-lg text-xs md:text-sm min-h-[80px]">
                <p id="dialogue-text"></p>
                <div id="dialogue-arrow" class="text-right mt-2 animate-pulse text-[10px] text-yellow-300 hidden">‚ñº
                    PRESS SPACE</div>
            </div>
        </div>

        <!-- Interaction Choice Buttons (Yes/No for Stranger) -->
        <div id="interaction-choice"
            class="absolute bottom-24 left-1/2 transform -translate-x-1/2 flex gap-8 hidden z-30 w-full justify-center px-4">
            <button id="btn-choice-yes"
                class="btn-retro bg-green-500 text-white px-6 py-3 rounded text-xs hover:bg-green-600">YES</button>
            <button id="btn-choice-no"
                class="btn-retro bg-red-500 text-white px-6 py-3 rounded text-xs hover:bg-red-600">NO</button>
        </div>

        <!-- Restart Menu (Mission Failed) -->
        <!-- CHANGED: absolute -> fixed, z-50 to make it cover the entire screen/viewport -->
        <div id="choice-container" class="fixed inset-0 bg-black/95 z-50 flex items-center justify-center hidden">
            <div
                class="choice-menu p-8 rounded-xl text-center max-w-md w-full border-4 border-red-500 bg-red-900/90 shadow-2xl">
                <h3 class="text-white text-3xl font-bold mb-6 text-red-500 drop-shadow-md animate-pulse">MISSION FAILED!
                </h3>

                <img src="https://media1.tenor.com/m/g0TdYZ1BMpgAAAAd/ishowspeed-meme.gif" alt="Failed"
                    class="w-full rounded-lg mb-6 border-4 border-white shadow-lg">

                <p class="text-white text-xl mb-8 font-bold text-yellow-300 drop-shadow-sm">"ooo gitu kasi ke cowo lain"
                </p>

                <div class="flex justify-center gap-4">
                    <button id="btn-restart-yes"
                        class="btn-retro bg-green-500 text-white px-8 py-4 rounded-lg text-lg w-full hover:bg-green-600 hover:scale-105 transition-transform font-bold shadow-lg">RESTART</button>
                </div>
            </div>
        </div>

        <!-- Interaction Hint -->
        <div id="interaction-hint"
            class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-white text-black px-4 py-2 rounded-full border-2 border-black hidden z-20 text-[10px] shadow-lg animate-bounce">
            PRESS SPACE
        </div>

        <!-- Stage 3 Modal -->
        <div id="modal-proposal"
            class="absolute inset-0 bg-black/90 z-30 flex flex-col items-center justify-center hidden">
            <div
                class="bg-pink-100 text-pink-900 p-8 rounded-xl border-4 border-pink-500 max-w-sm text-center shadow-[0_0_50px_rgba(236,72,153,0.5)] relative">
                <div class="text-5xl mb-6">üåπ</div>
                <h1 class="text-xl md:text-2xl text-pink-600 font-bold mb-2">Dear Chessa,</h1>
                <h2 class="text-lg mb-4 text-pink-500 font-bold">I found this for you...</h2>
                <p class="text-xs mb-8 leading-6">Will you be my Valentine?</p>

                <div class="flex justify-center gap-8 relative h-12 w-full">
                    <button id="btn-yes"
                        class="btn-retro bg-green-500 text-white px-6 py-2 rounded hover:bg-green-600 text-xs transition-transform duration-200">YES!</button>
                    <button id="btn-no"
                        class="btn-retro bg-red-500 text-white px-6 py-2 rounded hover:bg-red-600 absolute right-8 text-xs transition-all duration-200">NO</button>
                </div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls"
            class="absolute bottom-4 left-4 right-4 z-20 flex justify-between md:hidden opacity-60 hover:opacity-100 transition-opacity">
            <div class="relative w-32 h-32">
                <button id="btn-up"
                    class="absolute top-0 left-10 w-12 h-12 bg-gray-800/80 rounded-t-lg border border-gray-500 text-lg">‚ñ≤</button>
                <button id="btn-down"
                    class="absolute bottom-0 left-10 w-12 h-12 bg-gray-800/80 rounded-b-lg border border-gray-500 text-lg">‚ñº</button>
                <button id="btn-left"
                    class="absolute left-0 top-10 w-12 h-12 bg-gray-800/80 rounded-l-lg border border-gray-500 text-lg">‚óÄ</button>
                <button id="btn-right"
                    class="absolute right-0 top-10 w-12 h-12 bg-gray-800/80 rounded-r-lg border border-gray-500 text-lg">‚ñ∂</button>
            </div>
            <button id="btn-action"
                class="w-20 h-20 bg-red-600/90 rounded-full border-4 border-red-800 text-white shadow-lg active:bg-red-700 text-xl font-bold">A</button>
        </div>
    </div>

    <script>
        /** SOUND SYSTEM **/
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const SoundManager = {
            init: () => {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                const bgm = document.getElementById('bgm');
                if (bgm && bgm.paused) {
                    bgm.play().catch(e => console.log("Audio play failed (user interaction needed first):", e));
                }
            },
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playInteract: () => {
                SoundManager.playTone(600, 'square', 0.1);
                setTimeout(() => SoundManager.playTone(800, 'square', 0.1), 50);
            },
            playBlip: () => {
                SoundManager.playTone(1200, 'sine', 0.05, 0.05);
            },
            playStep: () => {
                // Optional: subtle noise
            },
            playWin: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                let time = audioCtx.currentTime;
                [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, time + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + i * 0.1 + 0.3);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(time + i * 0.1);
                    osc.stop(time + i * 0.1 + 0.3);
                });
            },
            playLose: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 1.0);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 1.0);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 1.0);
            }
        };

        // User Interaction to unlock Audio
        window.addEventListener('click', SoundManager.init, { once: true });
        window.addEventListener('keydown', SoundManager.init, { once: true });
        window.addEventListener('touchstart', SoundManager.init, { once: true });

        /** CONFIG & CONSTANTS **/
        const CANVAS_WIDTH = 480;
        const CANVAS_HEIGHT = 300;
        const SPEED = 2.5;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // State
        let state = {
            currentStage: 1,
            dialogueActive: false,
            choiceActive: false,
            gameFailed: false,
            inventory: { hasYellowFlower: false, hasRedFlower: false },
            isTransitioning: false,
            time: 0
        };

        const keys = { w: false, a: false, s: false, d: false, space: false };

        /** DRAWING HELPERS **/
        function drawCircle(x, y, radius, color, shadowColor = null) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            if (shadowColor) {
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 10;
            } else {
                ctx.shadowBlur = 0;
            }
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.closePath();
        }

        function drawCharacter(x, y, color, isMoving, direction, faceColor = '#ffe0bd') {
            const time = state.time;
            const legOffset = isMoving ? Math.sin(time / 80) * 4 : 0;
            ctx.fillStyle = '#1e293b';
            ctx.beginPath(); ctx.arc(x + 10, y + 28 + legOffset, 5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + 22, y + 28 - legOffset, 5, 0, Math.PI * 2); ctx.fill();

            const bob = isMoving ? Math.abs(Math.sin(time / 80)) * 2 : 0;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(x + 16, y + 32, 10, 3, 0, 0, Math.PI * 2); ctx.fill();

            drawCircle(x + 16, y + 16 - bob, 14, color);

            let faceX = x + 16, faceY = y + 14 - bob;
            if (direction === 'left') faceX -= 2;
            if (direction === 'right') faceX += 2;
            if (direction === 'up') faceY -= 1;
            if (direction === 'down') faceY += 1;

            drawCircle(faceX, faceY, 8, faceColor);

            ctx.fillStyle = '#000';
            let eyeOffsetX = 0, eyeOffsetY = 0;
            if (direction === 'left') eyeOffsetX = -3;
            if (direction === 'right') eyeOffsetX = 3;
            if (direction === 'up') eyeOffsetY = -2;

            if (direction !== 'up') {
                if (time % 3000 < 150) {
                    ctx.fillRect(faceX - 3 + eyeOffsetX, faceY + eyeOffsetY, 2, 1);
                    ctx.fillRect(faceX + 3 + eyeOffsetX, faceY + eyeOffsetY, 2, 1);
                } else {
                    ctx.beginPath();
                    ctx.arc(faceX - 3 + eyeOffsetX, faceY + eyeOffsetY, 1.5, 0, Math.PI * 2);
                    ctx.arc(faceX + 3 + eyeOffsetX, faceY + eyeOffsetY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawTree(x, y) {
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.ellipse(x + 16, y + 36, 14, 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 12, y + 20, 8, 16);
            drawCircle(x + 16, y + 18, 14, '#15803d');
            drawCircle(x + 10, y + 24, 10, '#166534');
            drawCircle(x + 22, y + 24, 10, '#166534');
            drawCircle(x + 16, y + 8, 10, '#22c55e');
        }

        function drawFlower(x, y, petalColor) {
            const sway = Math.sin(state.time / 300) * 2;
            ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x + 8, y + 16); ctx.quadraticCurveTo(x + 8 + sway, y + 8, x + 8, y); ctx.stroke();
            drawCircle(x + 8 + sway, y, 4, petalColor, petalColor);
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x + 8 + sway, y, 1.5, 0, Math.PI * 2); ctx.fill();
        }

        /** ENTITIES **/
        class GameObject {
            constructor(x, y, width, height, type) {
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.type = type; this.markedForDeletion = false; this.interactable = false;
                this.direction = 'down';
            }
            draw() {
                switch (this.type) {
                    case 'player': drawCharacter(this.x, this.y, '#ec4899', this.isMoving, this.direction); break; // Pink Player
                    case 'npc': drawCharacter(this.x, this.y, '#3b82f6', false, 'left'); break; // Blue Stranger
                    case 'flowerY': drawFlower(this.x, this.y, '#facc15'); break;
                    case 'flowerR': drawFlower(this.x, this.y, '#ef4444');
                        if (state.time % 1000 < 500) { ctx.fillStyle = 'white'; ctx.font = '10px serif'; ctx.fillText('‚ú®', this.x, this.y - 10); } break;
                    case 'tree': drawTree(this.x, this.y - 10); break;
                }
            }
            getBounds() {
                if (this.type === 'tree') return { x: this.x + 8, y: this.y + 20, w: 16, h: 10 };
                return { x: this.x, y: this.y, w: this.width, h: this.height };
            }
        }

        class Player extends GameObject {
            constructor(x, y) { super(x, y, 32, 32, 'player'); this.isMoving = false; }
            update() {
                if (state.dialogueActive || state.isTransitioning || state.gameFailed || state.choiceActive) return;

                let dx = 0, dy = 0;
                if (keys.w) { dy = -SPEED; this.direction = 'up'; }
                if (keys.s) { dy = SPEED; this.direction = 'down'; }
                if (keys.a) { dx = -SPEED; this.direction = 'left'; }
                if (keys.d) { dx = SPEED; this.direction = 'right'; }

                this.isMoving = (dx !== 0 || dy !== 0);

                if (!checkCollision(this.x + dx, this.y)) this.x += dx;
                if (!checkCollision(this.x, this.y + dy)) this.y += dy;

                this.x = Math.max(0, Math.min(CANVAS_WIDTH - 32, this.x));
                this.y = Math.max(0, Math.min(CANVAS_HEIGHT - 32, this.y));
            }
        }

        let player;
        let objects = [];
        let particles = [];

        function generateGrassParticles() {
            particles = [];
            for (let i = 0; i < 40; i++) particles.push({ x: Math.random() * CANVAS_WIDTH, y: Math.random() * CANVAS_HEIGHT, type: Math.random() > 0.8 ? 'flower' : 'grass' });
        }

        function drawMap() {
            ctx.fillStyle = '#4ade80'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#d6cd96';
            if (state.currentStage === 1) {
                ctx.beginPath(); ctx.ellipse(CANVAS_WIDTH - 64, 116, 50, 30, 0, 0, Math.PI * 2);
                ctx.ellipse(80, 116, 40, 20, 0, 0, Math.PI * 2); ctx.fill();
            } else if (state.currentStage === 2) {
                ctx.beginPath(); ctx.moveTo(30, 116); ctx.bezierCurveTo(100, 116, 100, 50, 200, 50);
                ctx.bezierCurveTo(300, 50, 300, 250, 400, 250); ctx.lineWidth = 40; ctx.strokeStyle = '#d6cd96'; ctx.stroke();
            }
            particles.forEach(p => {
                if (p.type === 'grass') { ctx.fillStyle = '#22c55e'; ctx.fillRect(p.x, p.y, 2, 4); }
                else { ctx.fillStyle = '#86efac'; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); }
            });
        }

        /** GAME LOGIC **/
        function resetGame() {
            SoundManager.playInteract();
            state = { currentStage: 1, dialogueActive: false, choiceActive: false, gameFailed: false, inventory: { hasYellowFlower: false, hasRedFlower: false }, isTransitioning: false, time: 0 };
            document.getElementById('choice-container').classList.add('hidden');
            document.getElementById('interaction-choice').classList.add('hidden');
            initStage1();
        }

        function showChoice(yesCallback, noCallback) {
            state.choiceActive = true;
            SoundManager.playInteract();
            const ui = document.getElementById('interaction-choice');
            const yesBtn = document.getElementById('btn-choice-yes');
            const noBtn = document.getElementById('btn-choice-no');

            ui.classList.remove('hidden');

            const newYes = yesBtn.cloneNode(true);
            const newNo = noBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newYes, yesBtn);
            noBtn.parentNode.replaceChild(newNo, noBtn);

            newYes.addEventListener('click', () => {
                SoundManager.playInteract();
                ui.classList.add('hidden');
                state.choiceActive = false;
                yesCallback();
            });
            newNo.addEventListener('click', () => {
                SoundManager.playInteract();
                ui.classList.add('hidden');
                state.choiceActive = false;
                noCallback();
            });
        }

        function initStage1() {
            player = new Player(CANVAS_WIDTH / 2 - 16, CANVAS_HEIGHT / 2 - 16);
            objects = [];
            generateGrassParticles();

            const npc = new GameObject(CANVAS_WIDTH - 80, 100, 32, 32, 'npc');
            npc.interactable = true;
            npc.onInteract = () => {
                if (state.inventory.hasYellowFlower) {
                    showDialogue("Stranger: Is that a yellow flower for me?", () => {
                        showChoice(
                            () => { // YES
                                showDialogue("Stranger: *Cough* *Sneeze* Oh no! I'm allergic! (Mission Failed)", () => {
                                    state.gameFailed = true;
                                    SoundManager.playLose();
                                    document.getElementById('choice-container').classList.remove('hidden');
                                });
                            },
                            () => { // NO
                                showDialogue("Stranger: You decided to keep it? Good. I'm actually allergic to those.", () => {
                                    showDialogue("Stranger: You are thoughtful. You may pass.", () => {
                                        npc.markedForDeletion = true;
                                        transitionToStage(2);
                                    });
                                });
                            }
                        );
                    });
                } else {
                    showDialogue("Stranger: You look kind. Please, go ahead.", () => {
                        npc.markedForDeletion = true;
                        transitionToStage(2);
                    });
                }
            };
            objects.push(npc);

            const flower = new GameObject(60, 100, 16, 16, 'flowerY');
            flower.interactable = true;
            flower.onInteract = () => {
                state.inventory.hasYellowFlower = true;
                flower.markedForDeletion = true;
                SoundManager.playWin();
                showDialogue("You picked a Yellow Flower! (It looks dusty...)");
            };
            objects.push(flower);

            createBorderTrees();
        }

        function initStage2() {
            player.x = 30; player.y = 100; objects = []; generateGrassParticles();
            for (let i = 0; i < 10; i++) {
                objects.push(new GameObject(150 + (i * 10), 0 + (i * 15), 32, 32, 'tree'));
                objects.push(new GameObject(250 - (i * 5), 300 - (i * 15), 32, 32, 'tree'));
            }
            objects.push(new GameObject(100, 200, 32, 32, 'tree'));
            objects.push(new GameObject(350, 50, 32, 32, 'tree'));

            const rose = new GameObject(CANVAS_WIDTH - 60, CANVAS_HEIGHT - 60, 16, 16, 'flowerR');
            rose.interactable = true;
            rose.onInteract = () => {
                state.inventory.hasRedFlower = true;
                SoundManager.playWin();
                showDialogue("This Red Rose is perfect.", () => { transitionToStage(3); });
            };
            objects.push(rose);
            createBorderTrees();
        }

        function createBorderTrees() {
            for (let x = 0; x < CANVAS_WIDTH; x += 30) {
                objects.push(new GameObject(x, -10, 32, 32, 'tree'));
                objects.push(new GameObject(x, CANVAS_HEIGHT - 20, 32, 32, 'tree'));
            }
        }

        function checkCollision(x, y) {
            const feet = { x: x + 10, y: y + 20, w: 12, h: 10 };
            for (let obj of objects) {
                if (obj.type === 'tree' || obj.type === 'npc') {
                    const b = obj.getBounds();
                    if (feet.x < b.x + b.w && feet.x + feet.w > b.x && feet.y < b.y + b.h && feet.y + feet.h > b.y) return true;
                }
            }
            return false;
        }

        function handleInteraction() {
            if (state.dialogueActive || state.choiceActive) { advanceDialogue(); return; }
            if (state.gameFailed) return;

            const pCenter = { x: player.x + 16, y: player.y + 16 };
            let closest = null, minDist = 60;
            for (let obj of objects) {
                if (obj.interactable) {
                    const dist = Math.hypot(pCenter.x - (obj.x + 16), pCenter.y - (obj.y + 16));
                    if (dist < minDist) { minDist = dist; closest = obj; }
                }
            }
            if (closest && closest.onInteract) {
                SoundManager.playInteract();
                closest.onInteract();
            }
        }

        function transitionToStage(num) {
            state.isTransitioning = true;
            let alpha = 0;
            SoundManager.playInteract();
            const t = setInterval(() => {
                ctx.fillStyle = `rgba(0,0,0,${alpha})`; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                alpha += 0.1;
                if (alpha >= 1) {
                    clearInterval(t); state.currentStage = num;
                    if (num === 2) initStage2(); if (num === 3) initStage3();
                    state.isTransitioning = false;
                }
            }, 50);
        }

        function initStage3() { document.getElementById('modal-proposal').classList.remove('hidden'); }

        /** DIALOGUE SYSTEM **/
        const diagUI = document.getElementById('dialogue-container');
        const diagText = document.getElementById('dialogue-text');
        const arrow = document.getElementById('dialogue-arrow');
        let diagTimer, diagCallback;
        let currentFullText = "";

        function showDialogue(text, cb) {
            state.dialogueActive = true;
            diagCallback = cb;
            currentFullText = text;
            diagUI.classList.remove('hidden');
            arrow.classList.add('hidden');
            diagText.textContent = "";

            let i = 0;
            clearInterval(diagTimer);
            diagTimer = setInterval(() => {
                diagText.textContent += text[i];
                if (i % 2 === 0) SoundManager.playBlip();
                i++;
                if (i >= text.length) {
                    clearInterval(diagTimer);
                    diagTimer = null;
                    arrow.classList.remove('hidden');
                }
            }, 30);
        }

        function advanceDialogue() {
            if (state.choiceActive) return;

            if (diagTimer !== null) {
                clearInterval(diagTimer);
                diagTimer = null;
                diagText.textContent = currentFullText;
                arrow.classList.remove('hidden');
                return;
            }

            state.dialogueActive = false;
            SoundManager.playInteract();
            diagUI.classList.add('hidden');
            if (diagCallback) diagCallback();
        }

        /** LOOP **/
        function update() {
            state.time += 16;
            if (state.currentStage !== 3) player.update();

            const hint = document.getElementById('interaction-hint');
            let show = false;
            objects.forEach(o => {
                if (o.interactable && Math.hypot(player.x - o.x, player.y - o.y) < 50) show = true;
            });
            if (show && !state.dialogueActive && !state.gameFailed && !state.choiceActive) hint.classList.remove('hidden');
            else hint.classList.add('hidden');
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawMap();
            const all = [...objects, player];
            all.sort((a, b) => (a.y + a.height) - (b.y + b.height));
            all.forEach(o => { if (!o.markedForDeletion) o.draw(); });
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }

        /** INPUTS **/
        window.addEventListener('keydown', e => {
            if (e.repeat) return;
            if (e.key === 'w' || e.key === 'ArrowUp') keys.w = true;
            if (e.key === 's' || e.key === 'ArrowDown') keys.s = true;
            if (e.key === 'a' || e.key === 'ArrowLeft') keys.a = true;
            if (e.key === 'd' || e.key === 'ArrowRight') keys.d = true;
            if (e.key === ' ' || e.key === 'Enter') handleInteraction();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'ArrowUp') keys.w = false;
            if (e.key === 's' || e.key === 'ArrowDown') keys.s = false;
            if (e.key === 'a' || e.key === 'ArrowLeft') keys.a = false;
            if (e.key === 'd' || e.key === 'ArrowRight') keys.d = false;
        });

        const bindBtn = (id, k) => {
            const b = document.getElementById(id);
            b.addEventListener('touchstart', e => { e.preventDefault(); keys[k] = true; });
            b.addEventListener('touchend', e => { e.preventDefault(); keys[k] = false; });
            b.addEventListener('mousedown', () => keys[k] = true);
            b.addEventListener('mouseup', () => keys[k] = false);
        };
        bindBtn('btn-up', 'w'); bindBtn('btn-down', 's'); bindBtn('btn-left', 'a'); bindBtn('btn-right', 'd');
        const act = document.getElementById('btn-action');
        act.addEventListener('touchstart', e => { e.preventDefault(); handleInteraction(); });
        act.addEventListener('click', handleInteraction);

        document.getElementById('btn-restart-yes').addEventListener('click', resetGame);

        // ENDING LOGIC: 5-Stage No Button
        const btnNo = document.getElementById('btn-no');
        const btnYes = document.getElementById('btn-yes');
        let noClickCount = 0;

        const handleNoInteraction = (e) => {
            if (e.type === 'touchstart') e.preventDefault();
            SoundManager.playLose();
            noClickCount++;

            const s = parseFloat(btnYes.style.transform.replace('scale(', '')) || 1;
            btnYes.style.transform = `scale(${s + 0.4})`;

            if (noClickCount >= 5) {
                btnNo.style.display = 'none';
            } else {
                const modal = document.getElementById('modal-proposal');

                if (btnNo.parentNode !== modal) {
                    modal.appendChild(btnNo);
                    btnNo.style.position = 'absolute';
                }

                const rect = modal.getBoundingClientRect();
                const btnW = 80;
                const btnH = 40;

                const corners = [
                    { x: 20, y: 20 },
                    { x: rect.width - btnW - 40, y: 20 },
                    { x: 20, y: rect.height - btnH - 40 },
                    { x: rect.width - btnW - 40, y: rect.height - btnH - 40 }
                ];

                const randomCorner = corners[Math.floor(Math.random() * corners.length)];

                const jitterX = (Math.random() * 40) - 20;
                const jitterY = (Math.random() * 40) - 20;

                btnNo.style.left = (randomCorner.x + jitterX) + 'px';
                btnNo.style.top = (randomCorner.y + jitterY) + 'px';

                btnNo.style.opacity = (1 - (noClickCount * 0.15));
                btnNo.style.transform = `scale(${1 - (noClickCount * 0.1)})`;

                const texts = ["Sure?", "Really?", "Pls?", "Last Try!"];
                btnNo.innerText = texts[noClickCount - 1] || "No";
            }
        };

        btnNo.addEventListener('touchstart', handleNoInteraction);
        btnNo.addEventListener('click', handleNoInteraction);

        btnYes.addEventListener('click', () => {
            SoundManager.playWin();
            SoundManager.playWin();
            // Hide the game wrapper completely
            document.getElementById('game-wrapper').style.display = 'none';

            // Create Full Screen Celebration Container
            const celebrationContainer = document.createElement('div');
            celebrationContainer.className = 'fixed inset-0 flex flex-col items-center justify-center z-50 bg-[#fce7f3]';
            celebrationContainer.innerHTML = `
                <div class="text-center px-4 flex flex-col items-center">
                    <h1 class="text-4xl md:text-6xl text-pink-600 font-bold mb-6 drop-shadow-md">HAPPY VALENTINE'S!</h1>
                    <p class="text-xl md:text-3xl mb-4 text-pink-800 font-semibold">Yay! I knew you would say yes!</p>
                    <p class="text-lg md:text-2xl text-pink-800 mb-8">You made me the happiest ‚ù§Ô∏è</p>
                    <img src="https://media1.tenor.com/m/o_5RQarGvJ0AAAAC/kiss.gif" alt="Kissing" class="rounded-xl shadow-2xl border-4 border-pink-400 w-64 mx-auto">
                </div>
            `;
            document.body.appendChild(celebrationContainer);

            // Confetti
            const end = Date.now() + 5000;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 }, colors: ['#ec4899'] });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 }, colors: ['#ec4899'] });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        });

        initStage1();
        loop();

    </script>
</body>

</html>